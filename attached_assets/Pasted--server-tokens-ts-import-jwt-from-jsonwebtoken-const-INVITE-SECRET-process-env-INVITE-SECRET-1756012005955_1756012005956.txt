📁 server/tokens.ts
import jwt from "jsonwebtoken";

const INVITE_SECRET = process.env.INVITE_SECRET || "dev-secret";

export function signInvite(payload: { email: string, org_id: string }) {
  return jwt.sign(payload, INVITE_SECRET, { expiresIn: "7d" });
}

export function verifyInvite(token: string) {
  try {
    return jwt.verify(token, INVITE_SECRET) as { email: string, org_id: string, iat: number, exp: number };
  } catch {
    return null;
  }
}

📁 server/routes/billing.ts
import { Router } from "express";
import { getOrg, updatePlan } from "../startup";

const r = Router();

r.get("/org", async (_req, res) => {
  const org = await getOrg();
  res.json({ org });
});

r.post("/upgrade", async (req, res) => {
  const { plan } = req.body || {};
  if (!plan) return res.status(400).json({ error: "plan required" });

  const updated = await updatePlan(plan);
  res.json({ ok: true, org: updated });
});

export default r;

📁 server/routes/invites.ts
import { Router } from "express";
import crypto from "crypto";
import { query } from "../db";
import { getOrg } from "../startup";
import { signInvite } from "../tokens";
import { sendInviteEmail } from "../mailer";

const r = Router();

r.post("/", async (req, res) => {
  const { emails } = req.body || {};
  if (!Array.isArray(emails) || emails.length === 0) return res.status(400).json({ error: "emails required" });

  const org = await getOrg();
  const seatsUsed = Number(org.seats_used || 0);
  const remaining = Number(org.seat_limit) - seatsUsed;
  if (emails.length > remaining) {
    return res.status(400).json({ error: `Not enough seats. Remaining: ${remaining}` });
  }

  let sent = 0;
  for (const email of emails) {
    const token = signInvite({ email, org_id: org.id });
    const expires = new Date(Date.now() + 7*24*3600*1000);
    await query(
      "INSERT INTO invites (id, org_id, email, token, expires_at) VALUES ($1,$2,$3,$4,$5)",
      [crypto.randomUUID(), org.id, email, token, expires]
    );

    const base = process.env.APP_BASE_URL || "http://localhost:5173";
    const url = `${base}/accept-invite?token=${encodeURIComponent(token)}`;
    await sendInviteEmail(email, url);
    sent++;
  }

  res.json({ ok: true, sent });
});

export default r;

📁 server/routes/auth.ts
import { Router } from "express";
import bcrypt from "bcryptjs";
import { verifyInvite } from "../tokens";
import { query } from "../db";

const r = Router();

r.post("/accept-invite", async (req, res) => {
  const { token, password } = req.body || {};
  if (!token || !password) return res.status(400).json({ error: "token and password required" });

  const payload = verifyInvite(token);
  if (!payload) return res.status(400).json({ error: "Invalid or expired token" });

  const inv = await query("SELECT * FROM invites WHERE token=$1", [token]);
  if (inv.rows.length === 0) return res.status(400).json({ error: "Invite not found" });
  const invite = inv.rows[0];
  if (invite.accepted_at) return res.status(400).json({ error: "Invite already accepted" });
  if (new Date(invite.expires_at) < new Date()) return res.status(400).json({ error: "Invite expired" });

  const userRes = await query("SELECT * FROM users WHERE email=$1", [payload.email]);
  const hash = await bcrypt.hash(password, 10);
  if (userRes.rows.length === 0) {
    await query(
      "INSERT INTO users (id, org_id, email, password_hash, role) VALUES (gen_random_uuid(), $1, $2, $3, 'member')",
      [payload.org_id, payload.email, hash]
    );
  } else {
    await query("UPDATE users SET password_hash=$1 WHERE email=$2", [hash, payload.email]);
  }

  await query("UPDATE invites SET accepted_at=now() WHERE token=$1", [token]);
  res.json({ ok: true });
});

export default r;

📁 server/scripts/init-db.ts
import { ensureSchema, createDefaultOrgAndOwner } from "../startup";

ensureSchema()
  .then(createDefaultOrgAndOwner)
  .then(() => { console.log("DB ready"); process.exit(0); })
  .catch(e => { console.error(e); process.exit(1); });
