// src/components/TaskBoard.tsx
import React from "react";
import {
  DndContext,
  closestCenter,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent
} from "@dnd-kit/core";
import {
  SortableContext,
  arrayMove,
  verticalListSortingStrategy
} from "@dnd-kit/sortable";
import TaskCard from "./TaskCard";

type Task = {
  id: string;
  title: string;
  completed: boolean;
  // ...any other fields (assigneeId, etc.)
};

type Props = {
  initialTasks: Task[];
  // called when a task’s completion toggles due to drag between columns
  onToggleComplete?: (id: string, completed: boolean) => Promise<void>;
};

export default function TaskBoard({ initialTasks, onToggleComplete }: Props) {
  // single source of truth for UI
  const [tasks, setTasks] = React.useState<Task[]>(initialTasks);

  // derive columns each render (don’t cache with stale memo)
  const todo = tasks.filter(t => !t.completed);
  const done = tasks.filter(t => t.completed);

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 6 } })
  );

  // helper to move within a list
  function reorder(list: Task[], activeId: string, overId: string) {
    const oldIndex = list.findIndex(t => t.id === activeId);
    const newIndex = list.findIndex(t => t.id === overId);
    if (oldIndex === -1 || newIndex === -1) return list;
    return arrayMove(list, oldIndex, newIndex);
  }

  function applyTask(id: string, updater: (t: Task) => Task): Task[] {
    return tasks.map(t => (t.id === id ? updater(t) : t));
  }

  async function handleDragEnd(e: DragEndEvent) {
    const { active, over } = e;
    if (!over) return;

    // "container ids" for columns: "todo" and "done"
    const activeContainer = active.data.current?.sortable?.containerId;
    const overContainer = over.data.current?.sortable?.containerId;

    // Reorder within the same column (pure UI move)
    if (activeContainer && overContainer && activeContainer === overContainer) {
      if (activeContainer === "todo") {
        const newTodo = reorder(todo, active.id as string, over.id as string);
        // merge back into tasks
        const newTasks = [
          ...newTodo,
          ...done // unchanged
        ];
        setTasks(newTasks);
      } else {
        const newDone = reorder(done, active.id as string, over.id as string);
        const newTasks = [
          ...todo,
          ...newDone
        ];
        setTasks(newTasks);
      }
      return;
    }

    // Moved across columns → toggle completed
    if (activeContainer !== overContainer) {
      const id = active.id as string;
      const toCompleted = overContainer === "done";

      // optimistic UI update so visuals change immediately
      const prev = tasks;
      const optimistic = applyTask(id, t => ({ ...t, completed: toCompleted }));
      setTasks(optimistic);

      try {
        // notify API (you already have backend working)
        await onToggleComplete?.(id, toCompleted);
      } catch (err) {
        // rollback if API rejects
        console.error("toggle failed, rolling back", err);
        setTasks(prev);
      }
    }
  }

  return (
    <div className="grid grid-cols-2 gap-4">
      <div className="rounded-2xl border p-3">
        <h2 className="mb-2 font-semibold">To Do</h2>
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            id="todo"
            items={todo.map(t => t.id)}
            strategy={verticalListSortingStrategy}
          >
            <ul className="space-y-2">
              {todo.map(t => (
                <TaskCard key={t.id} task={t} containerId="todo" />
              ))}
            </ul>
          </SortableContext>

          <h2 className="mb-2 mt-6 font-semibold">Done</h2>
          <SortableContext
            id="done"
            items={done.map(t => t.id)}
            strategy={verticalListSortingStrategy}
          >
            <ul className="space-y-2">
              {done.map(t => (
                <TaskCard key={t.id} task={t} containerId="done" />
              ))}
            </ul>
          </SortableContext>
        </DndContext>
      </div>
    </div>
  );
}
